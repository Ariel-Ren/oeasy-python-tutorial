---
show: step
version: 1.0
enable_checker: true
---

# 列表 - 构造

## 回忆

- 上次了解了列表的索引
- 可以用中括号加索引找到相应的元素
- 也可以用 index 找到元素的位置
- 还可以用 count 找到元素的匹配数量
- 列表中的元素可以进行什么样的计算么？🤔

### 回忆字符串

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630203640962)

- 字符串可以进行加法和乘法的运算
- 最大能有多少个元素呢？

### 试探边缘

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220706-1657069020797)

- 5个九好像也没有问题
- 没有问题就继续试探

### 边缘

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220706-1657069059401)

- 八个九之后自动退出python了

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220706-1657069234185)

- range函数对应的列表也会发生同样的问题
- 但如果比八个九还多会如何呢？

### 越过边缘

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220706-1657069085540)

- 更多九的时候根本就报一个内存错误
- 如果参数超过八字节的整数又会如何呢？

### 新的边缘

- 超过了八字节属于大数，不是一般的结构
	- 加减乘除还有定义
	- 但是想让他成为range的参数就不行了
	- 因为没有相应的处理函数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220903-1662157956962/wm)

- 在八字节里面也不是都能处理
	- 说明python的解释器毕竟还是受到内存的物理限制的

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220903-1662158060377/wm)

- 但是这个东西在内存里到底是什么样的过程呢?

### 观察
- 去一个网站观察
	- https://pythontutor.com/visualize.html#mode=edit

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630203709851)

### 演示

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630208623942)

- 点击 Live Programming Mode
- 然后进入到试试编程模式

### 字符串运算

- 这种直接的计算
- 并不能为内存中的变量赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209077502)

- 在左边的帧(frames)的位置是空的
- 现在尝试赋值

### 赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209062770)

- 有两个变量在 调用(call)栈(stack)的 帧(frame)上看得见了

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220903-1662158505337/wm)

- 可以用 prev 和 next 控制流程运行
- 数字型变量的情况呢？

### 数字变量

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209240049)

- 可以看到数字变量都在帧栈空间

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220903-1662158557838/wm)

- 那么列表 list 变量呢？

### 列表变量

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220903-1662163960956/wm)

- 可以看到 l 变量在栈帧上有一个位置
- 或者说在主程序的globals里面可见

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220706-1657092248699)

- 注意那条带箭头的线
- 左边的变量在 global frame 中
- 但是帧上只能看见l
	- l[0]等元素在哪里呢？

### 地址

- 帧上存着 l 的 引用(id)
- 也只能看见 l

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220903-1662164129442/wm)

- l[0]、l[1]、l[2]是由 l 在堆(heap)申请的内存
- 并且将引用(id) 存储在 l 中的
- 可以用l来访问l[0]
- 可以看到id(l[0]) 引用的就是 
	- "刘备" 在堆空间的地址
- 那 `append函数` 和 `+运算` 是如何进行的呢？

### 比较

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220706-1657091966023)

- 可以看到 `append函数` 返回的列表引用的内存位置还是原来的
- 那 `+运算` 呢？

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220706-1657092009900)

- 加法运算的返回列表的内存位置不是原来列表的内存位置了
- 如果把清空
- 会发生什么呢？

### 空列表

- 把空列表赋给 l
- l 仍然在 栈(frame) 上
- l 引用 堆(heap) 一个新的空列表

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220706-1657092518744)


- 原来的列表没有被任何变量所引用
- 会被垃圾回收
- 虽然指向一个空列表
- 但是还是指向一个具体的位置
- 如果我直接把l赋成None呢

### None

- 把 None 赋给 l
- l 仍然在栈(stack)上
- l 引用一个 常量None

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220903-1662164803799/wm)

- 堆空间里面刚才的空列表没有被任何变量所引用
- 会被垃圾回收
- 那不同的列表都指向None的话
- 内存地址是否一样呢？

### None的地址

- 至少l1和l2被赋成None之后
- 地址是一样的
- 都是id(None)
	- 我们甚至可以打印观察
	- print(id(None))

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220706-1657093290490)

- 那我们来看看列表的赋值运算

### 分别赋值

- l1、l2 是两个不同的列表
- 虽然内容都是 list("oeasy")
- 但是在堆空间是两个不同的 list

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210333943)

- 各是各的
- 那什么叫不是各是各的呢？

### 用列表赋值

- l2 = l1
- 让 l2 指向 l1 的地址

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210495419)

- 这样不论是 l1 还是 l2
- append 都会在同一个位置下添加列表项
- 如果我想要让 l2 的内容和 l1 相等
- 如何看到应用次数呢？


### getrefcount

- 这个函数可以得到 heap 中空间到底由几个变量进行引用

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630830125600)

- 明明是 l1、l2 两个变量啊
- 查看帮助
- 为什么显示为3呢？


### 帮助手册

- 本来确实应该是两个
- 但是由于这个函数调用的时候
- 在函数内部还有一个参数变量也引用了这个位置
- 所以会比想象地变量多 1

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630830139942)

- 如果我想将 l 复制为 l2
- 但是分别引用不同的地址空间
- 应该如何呢？

### copy 函数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210731635)

- 返回列表的浅拷贝
- 什么是拷贝呢？

### copy

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220728-1658976784346)

- 这个单词源于中世纪时候抄写文字
	- 后来也表示胶片的拷贝
	- 制片公司其实卖的是拷贝
- 后来有了复印机指的是复印
	- 到了电脑时代
	- 复制文件就是cp(copy)
	- 具体来试试

### 验证


- 拷贝明白了
- 两个列表分别的引用两个位置

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210778781)

- shallow copy(浅拷贝)是什么意思？
- 还不清楚
- 难道还有深拷贝不成？
- 再试试其他运算

### 加法运算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210864598)

- 首先是可以加的
- 但是加的结果没有赋给任何变量
- 就在寄存器的风中
- 消失了

### 加法并赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210997707)

- 把加法的结果赋给 l3
- l1、l2、l3 三个变量引用不同的地址
- 帧上有三个列表变量的引用
- 可以把这个东西赋给 l1 么？

### 赋值细节

- 加法运算是先复制 l1 里面的元素
- 然后追加 l2 里面的元素
- 最后把加法运算的结果再赋给 l1
- 帧上有两个列表变量的引用

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211221361)


- l1 原来所引用的地址没有人引用了
- 空间会被系统回收
- 能否直接在 l1 之后进行追加?

### 列表追加

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631580147683)

- 这里使用切片 a[3:]
- 其实就是在 a 的最后一个元素后面再追加列表 b
- 然后 a 就是被扩展 extend 了
- 这个时候其实有个新函数 extend

### extend

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211311655)

- extend 
	- 把参数里面的列表
	- 循环地放到extend方法的主体上
- 效率更高

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211378376)

- 而加法运算是新建一个列表
- 然后把 l1 的列表项都拿过来
- 再把 l2 的列表项都拿过来
- 最后把相加结果赋给 l1
- 效率不如extend

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211451887)

- 那这个 extend 和 append 有什么区别呢？

### 区别

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631579842400)

- 操作对象不同
- append 
	- 添加的是具体的元素
	- 添加的是一个列表项
- extend 
	- 是追加另一个列表
- 我们再试试乘法运算

### 乘法

- 乘法的本质就是累加

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630222596114)

- 本质就是生成一个新的列表
- 然后把这个新列表的实际地址
- 赋给一个在 帧(frame)上的 列表对象

### 空列表

- 如果本身就是空列表
- 列表里面没有列表项
- 乘多少还是空的

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630241238365)

- 但如果这里面有东西
- 乘出来列表项就翻倍了
- 即使里面是空列表
- 空列表也翻倍

### 总结

- 这次我们了解了列表的运算
- 赋值运算
  - 直接用列表赋值
	- 添加一个新列表
  - 直接用列表引用赋值
	  - 引用原来的列表位置 
  - 还可以用 浅copy 一个列表 再赋给变量
	  - 拷贝是明白了
	  - 不过浅是什么意思还不清楚
- 加法
  - 加法的本质是在 堆(heap) 中新建列表完成加法
  - 加法的结果可以被帧(frame)上的变量所引用
  - 也可以用 extend 在当前列表位置后继续追加列表
  - 还可以用 append 再当前列表位置后面继续追加列表项
- 乘法
  - 乘法的本质是累加
  - 结果像加法一样
  - 也是在 堆(heap) 上完成
  - 返回一个引用
  - 可以被赋值给变量
- 加法乘法都是让列表变长
- 可以让列表变短吗？🤔
- 下次再说 👋
